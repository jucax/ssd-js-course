<!DOCTYPE html>
<html>
    <head>
        <title>Advanced functions</title>
        <style>
            
        </style>
    </head>
    <body>

        <button onclick="" class="js-button">Click</button>

        <script>
            // .addEventListener(): let us run code when we interact with an element, like click a button, it is better than onclick=""
            const buttonElement = document.querySelector('.js-button');

            // First parameter is the event name
            // Second parameter is the function to run
            const eventListener = () => {
                console.log('click');
            };
            buttonElement.addEventListener('click', eventListener);

            // We can remove listeners, but just if we have the listener saved in a varaible previouly
            buttonElement.removeEventListener('click', eventListener);

            // We can have multiple listener (functions) when an event happens
            buttonElement.addEventListener('click', () => {
                console.log('click2');
            });


            // This 
            // Here we can do Hoisting which means we can call the function before we declare it
            greeting();
           function greeting() {
            console.log('hello');
           }
           // Is the same as this
           var greeting = function() {
            console.log('hello');
           };

           greeting();
           // Functions are valueas are numbers, strings or booleans
           const num = 2;
           // We can save functions inside variables
           // When we use a variable we dont need a function name, and make if anonymous function
           const function1 = function() {
            console.log('hello2');
           };

           console.log(function1);
           console.log(typeof function1);
           function1();

           // Functions can be saved inside objects, and become a method
           const object1 = {
            num: 2,
            // We can use it as anonymous
            fun: function () {
                console.log('hello3');
            }
           };
           object1.fun();

            // We knew that we can pass values to functions as parameters
           function display(param) {
            console.log(param);
           }
           display(2);

            // We can also pass functions inside functions as parameters
           function run(param) {
            param();
           }
           run(function() {
            console.log('hello4');
           });

           // setTimeout is a Built in function, it takes a function that we want to run in the future, and how long to wait in miliseconds
           setTimeout(function() {
            console.log('timeout');
           }, 3000);
           // Here JS is Asynchronous because it doesn't wait for setTimeout to finish before it starts the next line
           console.log('next line');

           // setTimeout doesn't block our code while the timing is runnis in second plane

           // setInverval takes the same parameters as setTimeout, but it will keep running the function every certain time
           setInterval(function() {
            console.log('interval');
           }, 3000);

           console.log('next line 2')

           // Another way to loop throught an array is with the method forEach()
           // For each value it send it as parameter to run de function
           const array = [
            'make dinner', 
            'wash dished', 
            'watch youtube'
           ].forEach(function(value, index) {
            if (value === 'wash dishes') {
                // return works as continue in for loops
                return;
            }
            console.log(index);
            console.log(value);
           });

           //forEach() is prefered than the for loop, is more redable and include another functions
           // There is no break in forEach, if we need break we should use for loops


           // Arrow Functions
           // They work the same way as a regular fuction, they just change the syntax and replace function for =>
           const arrowFunction = () => {
            console.log('hello');
           };
           arrowFunction();

           const regularFunction = function() {
            console.log('hello');
           };
           regularFunction();

            // In arrow functions, we can remove the () if we just have one parameter
           const oneParam = param => {
            console.log(param + 1);
           };
           oneParam(2);

           // If we just have one line, we can remove the {}, and the return also 
           const oneLine = () => { 
                return 2 + 3; 
            };    
            console.log(oneLine());

            const oneLineShortcut = () => 2 + 3; ;
           console.log(oneLineShortcut());

           // Arrow functions are recommended when we passing a function to another function
           setInterval(function() {
            console.log('interval');
           }, 10000);
           setInterval(() => {
            console.log('interval');
           }, 10000);

           const object2 = {
            // When we save a function inside an object, we can use arrow functions
            method: () => {

            },
            // But the shorthand syntax is preferred
            method() {

            }
           };


            // .filter(): This function will return a boolean value, but it just keep the value in the array if the function return true
            console.log([1, -3, 5].filter((value, index) => {
                /*
                if (value >= 0) {
                    return true;
                } else {
                    return false;
                }
                */
                return value >= 0;
            }));
            
            // .map(): This function will transform the array, so it change each value for the return result of the function
            console.log([1, 1, 3].map((value, index) => {
                return value * 2;
            }));

            // We can use arrow function shortcuts
            console.log([1, 1, 3].map(value => { return value * 2; }));


            // Closure means that the parameters of a function will be able to access just inside that function

        </script>
    </body>
</html>